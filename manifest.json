{"cyber-dojo.sh":"rm -f *.class\nCLASSES=.:`ls /junit/*.jar | tr '\\n' ':'`\njavac -Xlint:unchecked -Xlint:deprecation -cp $CLASSES  *.java\nif [ $? -eq 0 ]; then\n  # run test classes even if they are inner classes\n  # remove voluminous stack trace from output\n  java -cp $CLASSES org.junit.runner.JUnitCore `ls -1 *Test*.class | grep -v '\\\\$' | sed 's/\\(.*\\)\\..*/\\1/'` | grep -Ev 'org.junit.runner|org.junit.internal|sun.reflect|org.junit.Assert|java.lang.reflect|org.hamcrest'\nfi\n","output":"JUnit version 4.11-SNAPSHOT-20120416-1530\n.\nTime: 0.013\n\nOK (1 test)\n\n","instructions":"\nThis is an instructor-led exercise with no written instructions.\nYour instructor will explain the exercise.\n","ProfitTest.java":"import org.junit.*;\nimport static org.junit.Assert.*;\n\npublic class ProfitTest {\n\n    @Test\n    public void should_calculate_total_profits_for_the_year_in_Java6() {\n        // given\n        final double[] EXPECTED_SALES_JAN_TO_DEC =\n            new double[] { 42.0, 45.6, 43.6, 50.2, 55.6, 54.7,\n                    58.0, 57.3, 62.0, 60.3, 71.2, 88.8};\n        final Sales sales = new Sales(\n                FunctionOverTimeUtil.monthByMonth(EXPECTED_SALES_JAN_TO_DEC));\n\n        final FixedCosts fixedCosts = new FixedCosts(\n                FunctionOverTimeUtil.constant(15.0));\n\n        final IncrementalCosts incrementalCosts =\n                new IncrementalCosts(\n                FunctionOverTimeUtil.line(5.1, 0.15));\n\n        final Profit profit =\n                new Profit(\n                        sales,\n                        fixedCosts,\n                        incrementalCosts);\n\n        // when\n        double totalProfits = 0.0;\n        for(int time = 1; time <= 12; time ++) {\n            totalProfits += profit.valueAt(time);\n        }\n\n        // then\n        assertEquals(436.4, totalProfits, 0.001);\n    }\n}\n","FixedCosts.java":"\npublic class FixedCosts implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public FixedCosts(final FunctionOverTime valueFunction) {\n        this.valueFunction = valueFunction;\n    }\n\n    public String getName() {\n        return \"fixed costs\";\n    }\n\n    public double valueAt(final int time) {\n        return valueFunction.valueAt(time);\n    }\n}\n","FunctionOverTime.java":"\npublic interface FunctionOverTime {\n    public Double valueAt(final Integer time);\n}\n","FunctionOverTimeUtil.java":"\npublic class FunctionOverTimeUtil {\n\n    public static FunctionOverTime monthByMonth(final double[] array) {\n       return new FunctionOverTime() {\n           @Override\n           public Double valueAt(final Integer time) {\n               return array[time - 1];\n           }\n       };\n    }\n\n    public static FunctionOverTime constant(final double value) {\n        return polynomial(new double[] { value });\n    }\n\n    public static FunctionOverTime line(final double intercept, final double slope) {\n        return polynomial(new double[] { intercept, slope });\n    }\n\n    public static FunctionOverTime polynomial(final double[] coefficients) {\n        return new FunctionOverTime() {\n            @Override\n            public Double valueAt(final Integer time) {\n               double sum = 0.0;\n               for(int i = 0; i < coefficients.length; i++) {\n                   sum += coefficients[i] * Math.pow(time, i);\n               }\n               return sum;\n            }\n        };\n    }\n\n    public static interface FunctionOf3 {\n        public double apply(Double a, Double b, Double c);\n    }\n\n    static FunctionOverTime of3(final QuantityOfInterest a, final QuantityOfInterest b, final QuantityOfInterest c, final FunctionOf3 combination) {\n        return new FunctionOverTime() {\n            @Override\n            public Double valueAt(Integer time) {\n                return combination.apply(a.valueAt(time), b.valueAt(time), c.valueAt(time));\n            }\n        };\n    }\n}\n","IncrementalCosts.java":"\npublic class IncrementalCosts implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public IncrementalCosts(final FunctionOverTime valueFunction) {\n        this.valueFunction = valueFunction;\n    }\n\n    public String getName() {\n        return \"incremental costs\";\n    }\n\n    public double valueAt(final int time) {\n        return valueFunction.valueAt(time);\n    }\n}\n","Profit.java":"\npublic class Profit implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public Profit(final Sales sales, final FixedCosts fixedCosts, \n            final IncrementalCosts incrementalCosts) {\n        this.valueFunction = FunctionOverTimeUtil.of3(sales, fixedCosts, \n            incrementalCosts, new FunctionOverTimeUtil.FunctionOf3() {\n                @Override\n                public double apply(Double s, Double fc, Double ic) {\n                    return s - fc - ic;\n            }\n        });\n    }\n\n    public String getName() {\n        return \"profit!!\";\n    }\n\n    public double valueAt(final int time) {\n        return valueFunction.valueAt(time);\n    }\n}","Sales.java":"\npublic class Sales implements QuantityOfInterest {\n    private final FunctionOverTime valueFunction;\n\n    public Sales(final FunctionOverTime valueFunction) {\n        this.valueFunction = valueFunction;\n    }\n\n    public String getName() {\n        return \"sales\";\n    }\n\n    public double valueAt(final int time) {\n        return valueFunction.valueAt(time);\n    }\n}\n","QuantityOfInterest.java":"\npublic interface QuantityOfInterest {\n\n    String getName();\n\n    double valueAt(final int time);\n\n}\n"}